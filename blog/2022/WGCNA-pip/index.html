<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>ðŸ“¢ Streamline your WGCNA analysis pipeline | Hoang (Anh) Tran</title> <meta name="author" content="Hoang (Anh) Tran"> <meta name="description" content="Writing reproducible pipeline for your WGCNA analysis"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://hoangmgh.github.io/blog/2022/WGCNA-pip/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> </head> <body> <p> {% if jekyll.environment == 'production' and site.google_analytics %} {% include analytics.html %} {% endif %} </p> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">HoangÂ </span>(Anh)Â Tran</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Bioinformatics<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Arts</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">ðŸ“¢ Streamline your WGCNA analysis pipeline</h1> <p class="post-meta">January 12, 2022</p> <p class="post-tags"> <a href="/blog/2022"> <i class="fa-solid fa-calendar fa-sm"></i> 2022 </a> Â  Â· Â  <a href="/blog/tag/math"> <i class="fa-solid fa-hashtag fa-sm"></i> math</a> Â  <a href="/blog/tag/wgcna"> <i class="fa-solid fa-hashtag fa-sm"></i> WGCNA</a> Â  <a href="/blog/tag/systems-biology"> <i class="fa-solid fa-hashtag fa-sm"></i> systems-biology</a> Â  Â  Â· Â  <a href="/blog/category/bioinformatics"> <i class="fa-solid fa-tag fa-sm"></i> Bioinformatics</a> Â  </p> </header> <article class="post-content"> <div id="markdown-content"> <p>As I work with WGCNA to construct multiple single-cell genes network, I realize that the whole process is quite cumbersome, and the analysis will benefit greatly if we can make reproducible functions for parallel processing of multiple single-cell populations, power detection, module construction, and downstream analysis. Driven by this, I wrote a few functions for my own use. Feel free to use them if you are interested.</p> <p>The first step in WGCNA network construction is preprocessing of raw reads. Often times for RNA-seq data, such as scRNA-seq, one simple way to normalize would be CPM normalization, followed by log1p or log10p. We donâ€™t have to provide scaled data into WGCNAâ€™s pipeline - it is not necessary, and scaling doesnt change correlation, either. Moreover, there are some internal steps in WGCNA where they would check for missing data or sparseness (in the case that one have many 0s across genes).</p> <div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">preprocess_input</span><span class="o">=</span><span class="k">function</span><span class="w"> </span><span class="p">(</span><span class="n">meta_file</span><span class="p">,</span><span class="w"> </span><span class="n">count_file</span><span class="p">,</span><span class="w"> </span><span class="n">cluster_label</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"cluster"</span><span class="p">,</span><span class="w"> </span><span class="n">sample_label</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"sample"</span><span class="p">,</span><span class="w"> 
    </span><span class="n">vars_to_keep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s2">"sample"</span><span class="p">,</span><span class="w"> </span><span class="s2">"immune_infiltration_level"</span><span class="p">,</span><span class="w"> </span><span class="s2">"Condition"</span><span class="p">),</span><span class="w"> 
    </span><span class="n">normalize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">,</span><span class="w"> </span><span class="n">cluster_to_use</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s2">"all"</span><span class="p">),</span><span class="w"> </span><span class="n">normalize_method</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"edgeR"</span><span class="p">,</span><span class="w"> 
    </span><span class="n">remove_genes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Ig_rm</span><span class="p">,</span><span class="w"> </span><span class="n">vst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">,</span><span class="n">remove_low_count</span><span class="o">=</span><span class="kc">NA</span><span class="w">
                          </span><span class="p">)</span><span class="w"> 
    </span><span class="s1">'''
    parameters:
        meta_file: a metadata file for all population of cells, with
                    cluster_label: the columns correspond to cell-type (cluster)
                    sample_label: the column of sampleID
                    vars_to_keep: are the variables to be retained for further analyses
        normalize:whether to normalize the count data
        normalize_method: using existing package for normalization, such as edgeR or deSeq2
        vst: whether to use variance stabilizing transformation alongside with deseq2 normalization
        cluster_to_use: indicating the cell population to be used, default to all existing populations 
        remove_low_count: remove genes with a total sum of counts surpassing this value, or NA if use all available genes
        removes_genes: remove genes from a given blacklist, or NA to keep the existing set of geness
    output:
        raw_data: keep the raw counts for all populations/clusters
        normalized_data: keep the normalized counts for the given clusters in cluster_to_use
        metadata: the metadata for each population, seperately. The sample names will align with the rownames of the count matrix
 
    '''</span><span class="w">
</span><span class="p">{</span><span class="w">
    </span><span class="n">print</span><span class="p">(</span><span class="s2">"1. read in metadata:"</span><span class="p">)</span><span class="w">
    </span><span class="c1">################################################</span><span class="w">
    </span><span class="n">dat_meta</span><span class="w"> </span><span class="o">&lt;&lt;-</span><span class="w"> </span><span class="n">data.frame</span><span class="p">(</span><span class="n">as.matrix</span><span class="p">(</span><span class="n">fread</span><span class="p">(</span><span class="n">meta_file</span><span class="p">),</span><span class="w"> </span><span class="n">rownames</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">))</span><span class="w">
    </span><span class="n">clusters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">unique</span><span class="p">(</span><span class="n">dat_meta</span><span class="p">[[</span><span class="n">cluster_label</span><span class="p">]])</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">length</span><span class="p">(</span><span class="n">cluster_to_use</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">cluster_to_use</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">"all"</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="n">print</span><span class="p">(</span><span class="s2">"use all clusters"</span><span class="p">)</span><span class="w">
        </span><span class="n">cluster_to_use</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clusters</span><span class="w">
    </span><span class="p">}</span><span class="w">
    </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">any</span><span class="p">(</span><span class="n">cluster_to_use</span><span class="w"> </span><span class="o">%in%</span><span class="w"> </span><span class="n">dat_meta</span><span class="p">[[</span><span class="n">cluster_label</span><span class="p">]]))</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="n">print</span><span class="p">(</span><span class="s2">"one of cluster is not in datameta"</span><span class="p">)</span><span class="w">
        </span><span class="p">}</span><span class="w">
        
    </span><span class="p">}</span><span class="w">
    </span><span class="n">print</span><span class="p">(</span><span class="n">paste0</span><span class="p">(</span><span class="s2">"using a total of:"</span><span class="p">,</span><span class="w"> </span><span class="nf">length</span><span class="p">(</span><span class="n">cluster_to_use</span><span class="p">),</span><span class="w"> 
        </span><span class="s2">" unique clusters"</span><span class="p">))</span><span class="w">
    </span><span class="c1">################################################</span><span class="w">
    </span><span class="n">dat_meta_splitted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lapply</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="n">dat_meta</span><span class="p">[</span><span class="n">which</span><span class="p">(</span><span class="n">dat_meta</span><span class="p">[[</span><span class="n">cluster_label</span><span class="p">]]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="p">]</span><span class="w">
    </span><span class="p">})</span><span class="w">
    </span><span class="nf">names</span><span class="p">(</span><span class="n">dat_meta_splitted</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clusters</span><span class="w">
    </span><span class="n">print</span><span class="p">(</span><span class="s2">"2. sanity check  metadata:"</span><span class="p">)</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">sum</span><span class="p">(</span><span class="o">!</span><span class="n">table</span><span class="p">(</span><span class="n">dat_meta</span><span class="p">[[</span><span class="n">cluster_label</span><span class="p">]],</span><span class="w"> </span><span class="n">dat_meta</span><span class="p">[[</span><span class="n">sample_label</span><span class="p">]])</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> 
        </span><span class="m">1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="n">print</span><span class="p">(</span><span class="s2">"more than 2 identical samples  exist in one cluster"</span><span class="p">)</span><span class="w">
        </span><span class="k">break</span><span class="w">
    </span><span class="p">}</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="n">sample_label</span><span class="w"> </span><span class="o">%in%</span><span class="w"> </span><span class="n">colnames</span><span class="p">(</span><span class="n">dat_meta_splitted</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="n">print</span><span class="p">(</span><span class="s2">"sample label must exist in metadata"</span><span class="p">)</span><span class="w">
    </span><span class="p">}</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="nf">all</span><span class="p">(</span><span class="n">vars_to_keep</span><span class="w"> </span><span class="o">%in%</span><span class="w"> </span><span class="n">colnames</span><span class="p">(</span><span class="n">dat_meta_splitted</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="n">print</span><span class="p">(</span><span class="s2">"all variables used  must exist in metadata"</span><span class="p">)</span><span class="w">
    </span><span class="p">}</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">sample_label</span><span class="w"> </span><span class="o">%in%</span><span class="w"> </span><span class="n">vars_to_keep</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="n">print</span><span class="p">(</span><span class="s2">"sample label and cluster label must be in vars_to_keep"</span><span class="p">)</span><span class="w">
        </span><span class="k">break</span><span class="w">
    </span><span class="p">}</span><span class="w">
    
    </span><span class="n">dat</span><span class="w"> </span><span class="o">=</span><span class="n">as.matrix</span><span class="p">(</span><span class="n">fread</span><span class="p">(</span><span class="n">count_file</span><span class="p">),</span><span class="w"> </span><span class="n">rownames</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w">
   
    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">length</span><span class="p">(</span><span class="n">remove_genes</span><span class="p">)</span><span class="o">&gt;</span><span class="m">1</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">!</span><span class="nf">is.na</span><span class="p">(</span><span class="n">remove_genes</span><span class="p">[</span><span class="m">1</span><span class="p">])){</span><span class="w">
        </span><span class="n">print</span><span class="p">(</span><span class="s2">"3. remove gene in the blacklist:"</span><span class="p">)</span><span class="w">
        </span><span class="n">dat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dat</span><span class="p">[</span><span class="n">which</span><span class="p">(</span><span class="o">!</span><span class="n">rownames</span><span class="p">(</span><span class="n">dat</span><span class="p">)</span><span class="w"> </span><span class="o">%in%</span><span class="w"> </span><span class="n">remove_genes</span><span class="p">),</span><span class="w"> </span><span class="p">]</span><span class="w">       
    </span><span class="p">}</span><span class="w">
      </span><span class="n">print</span><span class="p">(</span><span class="n">paste0</span><span class="p">(</span><span class="s2">"remaining genes"</span><span class="p">,</span><span class="w"> </span><span class="n">nrow</span><span class="p">(</span><span class="n">dat</span><span class="p">)))</span><span class="w">
    </span><span class="n">dat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lapply</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">t</span><span class="p">(</span><span class="n">dat</span><span class="p">[,</span><span class="w"> </span><span class="n">which</span><span class="p">(</span><span class="n">dat_meta</span><span class="p">[[</span><span class="n">cluster_label</span><span class="p">]]</span><span class="w"> </span><span class="o">==</span><span class="w"> 
        </span><span class="n">i</span><span class="p">)]))</span><span class="w">
                 
    </span><span class="nf">names</span><span class="p">(</span><span class="n">dat</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clusters</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nf">is.na</span><span class="p">(</span><span class="n">remove_low_count</span><span class="p">)){</span><span class="w">
        </span><span class="n">print</span><span class="p">(</span><span class="s2">"removing genes with low counts overall:"</span><span class="p">)</span><span class="w">

        </span><span class="n">keep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lapply</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">colnames</span><span class="p">(</span><span class="n">dat</span><span class="p">[[</span><span class="n">i</span><span class="p">]])[</span><span class="n">which</span><span class="p">(</span><span class="n">colSums</span><span class="p">(</span><span class="n">dat</span><span class="p">[[</span><span class="n">i</span><span class="p">]],</span><span class="n">na.rm</span><span class="o">=</span><span class="nb">T</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="n">remove_low_count</span><span class="p">)])</span><span class="w">
        </span><span class="n">print</span><span class="p">(</span><span class="n">paste0</span><span class="p">(</span><span class="s2">"remaining genes: "</span><span class="p">,</span><span class="w"> </span><span class="nf">length</span><span class="p">(</span><span class="n">keep</span><span class="p">[[</span><span class="m">1</span><span class="p">]])))</span><span class="w">
    </span><span class="p">}</span><span class="w">
    </span><span class="k">else</span><span class="p">{</span><span class="w">
    </span><span class="n">print</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span><span class="w">
    </span><span class="n">keep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lapply</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">colnames</span><span class="p">(</span><span class="n">dat</span><span class="p">[[</span><span class="n">i</span><span class="p">]]))</span><span class="w">  
    </span><span class="p">}</span><span class="w">                      
    </span><span class="nf">names</span><span class="p">(</span><span class="n">keep</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clusters</span><span class="w">
    </span><span class="n">print</span><span class="p">(</span><span class="s2">"replace NA with 0 for calculating CPM:"</span><span class="p">)</span><span class="w">
    </span><span class="n">na_mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lapply</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">apply</span><span class="p">(</span><span class="n">dat</span><span class="p">[[</span><span class="n">i</span><span class="p">]],</span><span class="m">2</span><span class="p">,</span><span class="n">is.na</span><span class="p">))</span><span class="w">
    </span><span class="nf">names</span><span class="p">(</span><span class="n">na_mask</span><span class="p">)</span><span class="o">=</span><span class="n">clusters</span><span class="w">
    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">clusters</span><span class="p">){</span><span class="w">
           </span><span class="n">dat</span><span class="p">[[</span><span class="n">i</span><span class="p">]][</span><span class="n">na_mask</span><span class="p">[[</span><span class="n">i</span><span class="p">]]]</span><span class="o">=</span><span class="m">0</span><span class="w">
    </span><span class="p">}</span><span class="w">
 
    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="nf">seq_along</span><span class="p">(</span><span class="n">dat_meta_splitted</span><span class="p">))</span><span class="w"> </span><span class="n">rownames</span><span class="p">(</span><span class="n">dat_meta_splitted</span><span class="p">[[</span><span class="n">i</span><span class="p">]])</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">dat_meta_splitted</span><span class="p">[[</span><span class="n">i</span><span class="p">]][[</span><span class="n">sample_label</span><span class="p">]]</span><span class="w">
    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="nf">seq_along</span><span class="p">(</span><span class="n">dat_meta_splitted</span><span class="p">))</span><span class="w"> </span><span class="n">rownames</span><span class="p">(</span><span class="n">dat</span><span class="p">[[</span><span class="n">i</span><span class="p">]])</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">rownames</span><span class="p">(</span><span class="n">dat_meta_splitted</span><span class="p">[[</span><span class="n">i</span><span class="p">]])</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">normalize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">normalize_method</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">"deseq2"</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="n">print</span><span class="p">(</span><span class="s2">"using deseq2 normalization"</span><span class="p">)</span><span class="w">
            </span><span class="n">dds</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lapply</span><span class="p">(</span><span class="n">cluster_to_use</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">DESeqDataSetFromMatrix</span><span class="p">(</span><span class="n">countData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">(</span><span class="n">dat</span><span class="p">[[</span><span class="n">i</span><span class="p">]]),</span><span class="w"> 
                </span><span class="n">colData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data.frame</span><span class="p">(</span><span class="n">dat_meta_splitted</span><span class="p">[[</span><span class="n">i</span><span class="p">]]),</span><span class="w"> 
                </span><span class="n">design</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">~</span><span class="m">1</span><span class="p">))</span><span class="w">
            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vst</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="n">print</span><span class="p">(</span><span class="s2">"using VST"</span><span class="p">)</span><span class="w">
                </span><span class="n">vsd</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">lapply</span><span class="p">(</span><span class="n">dds</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">vst</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">blind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">))</span><span class="w">
                </span><span class="n">mat</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">lapply</span><span class="p">(</span><span class="n">vsd</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">t</span><span class="p">(</span><span class="n">assay</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span><span class="w">
                </span><span class="nf">names</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cluster_to_use</span><span class="w">
                </span><span class="n">multiExpr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lapply</span><span class="p">(</span><span class="n">cluster_to_use</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mat</span><span class="p">[[</span><span class="n">i</span><span class="p">]][,</span><span class="w"> 
                  </span><span class="n">keep</span><span class="p">[[</span><span class="n">i</span><span class="p">]]]))</span><span class="w">
                                   
                </span><span class="nf">names</span><span class="p">(</span><span class="n">multiExpr</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cluster_to_use</span><span class="w">
            </span><span class="p">}</span><span class="w">
            </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="nf">names</span><span class="p">(</span><span class="n">dds</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cluster_to_use</span><span class="w">
                </span><span class="n">dds</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lapply</span><span class="p">(</span><span class="n">dds</span><span class="p">,</span><span class="w"> </span><span class="n">estimateSizeFactors</span><span class="p">)</span><span class="w">
                </span><span class="n">multiExpr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lapply</span><span class="p">(</span><span class="n">cluster_to_use</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">(</span><span class="n">log10</span><span class="p">(</span><span class="n">counts</span><span class="p">(</span><span class="n">dds</span><span class="p">[[</span><span class="n">i</span><span class="p">]],</span><span class="w"> 
                  </span><span class="n">normalized</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">T</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">))))</span><span class="w">
                </span><span class="nf">names</span><span class="p">(</span><span class="n">multiExpr</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cluster_to_use</span><span class="w">
            </span><span class="p">}</span><span class="w">
                                   
        </span><span class="p">}</span><span class="w">
                                   
        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">normalize_method</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">"edgeR"</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="n">print</span><span class="p">(</span><span class="s2">"using edgeR normalization:"</span><span class="p">)</span><span class="w">
            </span><span class="n">multiExpr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lapply</span><span class="p">(</span><span class="n">cluster_to_use</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="nf">list</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">(</span><span class="n">cpm</span><span class="p">(</span><span class="n">t</span><span class="p">(</span><span class="n">dat</span><span class="p">[[</span><span class="n">i</span><span class="p">]]),</span><span class="w"> </span><span class="n">log</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">T</span><span class="p">)))})</span><span class="w">
            </span><span class="nf">names</span><span class="p">(</span><span class="n">multiExpr</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cluster_to_use</span><span class="w">
            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">clusters</span><span class="p">){</span><span class="w">
               </span><span class="n">multiExpr</span><span class="p">[[</span><span class="n">i</span><span class="p">]]</span><span class="o">$</span><span class="n">data</span><span class="p">[</span><span class="n">na_mask</span><span class="p">[[</span><span class="n">i</span><span class="p">]]]</span><span class="o">=</span><span class="kc">NA</span><span class="w">
               </span><span class="n">dat</span><span class="p">[[</span><span class="n">i</span><span class="p">]][</span><span class="n">na_mask</span><span class="p">[[</span><span class="n">i</span><span class="p">]]]</span><span class="o">=</span><span class="kc">NA</span><span class="w">
            </span><span class="p">}</span><span class="w">

            </span><span class="n">multiExpr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lapply</span><span class="p">(</span><span class="n">cluster_to_use</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="n">selected</span><span class="o">=</span><span class="n">colnames</span><span class="p">(</span><span class="n">multiExpr</span><span class="p">[[</span><span class="n">i</span><span class="p">]]</span><span class="o">$</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="o">%in%</span><span class="w"> </span><span class="n">keep</span><span class="p">[[</span><span class="n">i</span><span class="p">]]</span><span class="w">
                </span><span class="nf">return</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">multiExpr</span><span class="p">[[</span><span class="n">i</span><span class="p">]]</span><span class="o">$</span><span class="n">data</span><span class="p">[,</span><span class="n">selected</span><span class="p">]))</span><span class="w">
            </span><span class="p">}</span><span class="w">
            </span><span class="p">)</span><span class="w">
            </span><span class="nf">names</span><span class="p">(</span><span class="n">multiExpr</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cluster_to_use</span><span class="w">

        </span><span class="p">}</span><span class="w">        
    </span><span class="p">}</span><span class="w">
    </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="n">multiExpr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lapply</span><span class="p">(</span><span class="n">cluster_to_use</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dat</span><span class="p">[[</span><span class="n">i</span><span class="p">]][,</span><span class="w"> 
         </span><span class="n">keep</span><span class="p">[[</span><span class="n">i</span><span class="p">]]]))</span><span class="w">
        </span><span class="nf">names</span><span class="p">(</span><span class="n">multiExpr</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cluster_to_use</span><span class="w">
    </span><span class="p">}</span><span class="w">
    </span><span class="nf">return</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">raw_data</span><span class="o">=</span><span class="n">dat</span><span class="p">,</span><span class="w"> </span><span class="n">normalized_data</span><span class="o">=</span><span class="n">multiExpr</span><span class="p">,</span><span class="w"> </span><span class="n">metadata</span><span class="o">=</span><span class="n">dat_meta_splitted</span><span class="p">))</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <p>the next step would be finding the appropriate powers for each population of cell. With this we have the find_power() function:</p> <div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">find_power</span><span class="o">=</span><span class="k">function</span><span class="p">(</span><span class="n">multiExpr</span><span class="p">,</span><span class="n">which_cluster</span><span class="o">=</span><span class="s2">"all"</span><span class="p">,</span><span class="n">meta</span><span class="p">,</span><span class="n">blockSize</span><span class="o">=</span><span class="m">30000</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="m">2</span><span class="p">,</span><span class="n">corFnc</span><span class="o">=</span><span class="n">WGCNA</span><span class="o">::</span><span class="n">cor</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="s1">'''
    multiExpr: a list of normalized datamatrix created from calling preprocess_input()
    which_cluster: which cluster to find power for. default to all
    blockSize: number of genes to be processed in parallel
    corFnc: correlation function to be used, default to WGCNA s cor 
    '''</span><span class="w">

    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">length</span><span class="p">(</span><span class="n">which_cluster</span><span class="p">)</span><span class="o">==</span><span class="m">1</span><span class="w"> </span><span class="o">&amp;</span><span class="n">which_cluster</span><span class="o">==</span><span class="s2">"all"</span><span class="p">){</span><span class="w">
        </span><span class="n">nSet</span><span class="o">=</span><span class="nf">length</span><span class="p">(</span><span class="n">multiExpr</span><span class="p">)</span><span class="w">
        </span><span class="n">which_cluster</span><span class="o">=</span><span class="nf">names</span><span class="p">(</span><span class="n">multiExpr</span><span class="p">)</span><span class="w">
    </span><span class="p">}</span><span class="w">
    </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">nSet</span><span class="o">=</span><span class="nf">length</span><span class="p">(</span><span class="n">which_cluster</span><span class="p">)</span><span class="w">
    </span><span class="p">}</span><span class="w">
    
    </span><span class="n">powers</span><span class="w"> </span><span class="o">&lt;&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="n">seq</span><span class="p">(</span><span class="m">2</span><span class="p">,</span><span class="m">10</span><span class="p">,</span><span class="n">by</span><span class="o">=</span><span class="m">1</span><span class="p">),</span><span class="w"> </span><span class="n">seq</span><span class="p">(</span><span class="m">12</span><span class="p">,</span><span class="m">20</span><span class="p">,</span><span class="w"> </span><span class="n">by</span><span class="o">=</span><span class="m">2</span><span class="p">));</span><span class="w">
    </span><span class="c1"># Initialize a list to hold the results of scale-free analysis</span><span class="w">
    </span><span class="n">powerTables</span><span class="w"> </span><span class="o">&lt;&lt;-</span><span class="w"> </span><span class="n">vector</span><span class="p">(</span><span class="n">mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"list"</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nSet</span><span class="p">);</span><span class="w">
    </span><span class="c1"># Call the network topology analysis function for each set in turn</span><span class="w">
    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">set</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="nf">seq_along</span><span class="p">(</span><span class="n">which_cluster</span><span class="p">)){</span><span class="w">
      </span><span class="n">powerTables</span><span class="p">[[</span><span class="n">set</span><span class="p">]]</span><span class="w"> </span><span class="o">&lt;&lt;-</span><span class="nf">list</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pickSoftThreshold</span><span class="p">(</span><span class="n">multiExpr</span><span class="p">[[</span><span class="n">which_cluster</span><span class="p">[</span><span class="n">set</span><span class="p">]]]</span><span class="o">$</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">powerVector</span><span class="o">=</span><span class="n">powers</span><span class="p">,</span><span class="w">
                                                         </span><span class="n">verbose</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="n">corFnc</span><span class="o">=</span><span class="n">corFnc</span><span class="p">,</span><span class="n">blockSize</span><span class="o">=</span><span class="m">30000</span><span class="p">)[[</span><span class="m">2</span><span class="p">]])</span><span class="w">
      
    </span><span class="n">collectGarbage</span><span class="p">();</span><span class="w">
    </span><span class="c1"># Plot the results:</span><span class="w">
    </span><span class="c1"># Will plot these columns of the returned scale free analysis tables</span><span class="w">
    </span><span class="nf">names</span><span class="p">(</span><span class="n">powerTables</span><span class="p">)</span><span class="o">=</span><span class="n">which_cluster</span><span class="w">
    </span><span class="nf">return</span><span class="p">(</span><span class="n">powerTables</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <p>After calling this function, one would go on to construct the network, the most time-consuming step:</p> <div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">construct_network</span><span class="o">=</span><span class="k">function</span><span class="p">(</span><span class="n">multiExpr</span><span class="p">,</span><span class="n">which_cluster</span><span class="o">=</span><span class="s2">"all"</span><span class="p">,</span><span class="n">nThreads</span><span class="o">=</span><span class="m">30</span><span class="p">,</span><span class="n">power_list</span><span class="p">,</span><span class="n">minModuleSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">50</span><span class="p">,</span><span class="w"> </span><span class="n">reassignThreshold</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> 
                           </span><span class="n">mergeCutHeight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">.15</span><span class="p">,</span><span class="n">numericLabels</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">pamRespectsDendro</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">saveTOMs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">,</span><span class="w">
                      </span><span class="n">verbose</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">3</span><span class="p">,</span><span class="n">maxBlockSize</span><span class="o">=</span><span class="m">30000</span><span class="p">,</span><span class="n">deepSplit</span><span class="o">=</span><span class="m">4</span><span class="p">,</span><span class="w">  </span><span class="n">checkMissingData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">,</span><span class="w">
                      </span><span class="n">corFnc</span><span class="o">=</span><span class="n">WGCNA</span><span class="o">::</span><span class="n">cor</span><span class="p">,</span><span class="n">save_output</span><span class="o">=</span><span class="kc">NA</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="s1">'''
    multiExpr:the list of normalized matrices from step1 (preprocess_input)
    which_cluster: the list of cluster to use, default to all ("all")
    nThreads: number of threads to run WGCNA
    power_list: the list of power detected from step2 (find_powers()), must match the number of clusters to process
    for other parameters, consult WGCNA manual 
'''</span><span class="w">
</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">length</span><span class="p">(</span><span class="n">which_cluster</span><span class="p">)</span><span class="o">==</span><span class="m">1</span><span class="w"> </span><span class="o">&amp;</span><span class="n">which_cluster</span><span class="o">==</span><span class="s2">"all"</span><span class="p">)</span><span class="w"> </span><span class="n">cluster_to_use</span><span class="o">=</span><span class="w"> </span><span class="nf">names</span><span class="p">(</span><span class="n">multiExpr</span><span class="p">)</span><span class="w">
</span><span class="k">else</span><span class="w"> </span><span class="n">cluster_to_use</span><span class="o">=</span><span class="n">which_cluster</span><span class="w">

</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">length</span><span class="p">(</span><span class="n">cluster_to_use</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nf">length</span><span class="p">(</span><span class="n">power_list</span><span class="p">)){</span><span class="w">
    </span><span class="n">print</span><span class="p">(</span><span class="s2">"the length of the power list must match the number of clusters"</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">    
</span><span class="nf">names</span><span class="p">(</span><span class="n">power_list</span><span class="p">)</span><span class="o">=</span><span class="n">cluster_to_use</span><span class="w">

</span><span class="n">net</span><span class="o">=</span><span class="n">lapply</span><span class="p">(</span><span class="n">cluster_to_use</span><span class="p">,</span><span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
     </span><span class="n">blockwiseModules</span><span class="p">(</span><span class="n">multiExpr</span><span class="p">[[</span><span class="n">i</span><span class="p">]]</span><span class="o">$</span><span class="n">data</span><span class="p">,</span><span class="n">nThreads</span><span class="o">=</span><span class="n">nThreads</span><span class="p">,</span><span class="w"> </span><span class="n">power</span><span class="w"> </span><span class="o">=</span><span class="n">power_list</span><span class="p">[[</span><span class="n">i</span><span class="p">]],</span><span class="w">
                      </span><span class="n">minModuleSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">minModuleSize</span><span class="p">,</span><span class="w"> </span><span class="n">reassignThreshold</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">reassignThreshold</span><span class="p">,</span><span class="w"> </span><span class="n">mergeCutHeight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mergeCutHeight</span><span class="p">,</span><span class="w"> 
                      </span><span class="n">numericLabels</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numericLabels</span><span class="p">,</span><span class="w"> </span><span class="n">pamRespectsDendro</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pamRespectsDendro</span><span class="p">,</span><span class="w"> </span><span class="n">saveTOMs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">saveTOMs</span><span class="p">,</span><span class="w">
                      </span><span class="n">verbose</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">verbose</span><span class="p">,</span><span class="n">maxBlockSize</span><span class="o">=</span><span class="n">maxBlockSize</span><span class="p">,</span><span class="n">deepSplit</span><span class="o">=</span><span class="n">deepSplit</span><span class="p">,</span><span class="w">  </span><span class="n">checkMissingData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">checkMissingData</span><span class="p">,</span><span class="w">
                      </span><span class="n">corFnc</span><span class="o">=</span><span class="n">corFnc</span><span class="p">)})</span><span class="w">
</span><span class="nf">names</span><span class="p">(</span><span class="n">net</span><span class="p">)</span><span class="o">=</span><span class="nf">names</span><span class="p">(</span><span class="n">cluster_to_use</span><span class="p">)</span><span class="w">
</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nf">is.na</span><span class="p">(</span><span class="n">save_output</span><span class="p">)){</span><span class="w">
</span><span class="n">saveRDS</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="n">save_output</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="nf">return</span><span class="p">(</span><span class="n">net</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <p>The next step would be processing the assignments of genes, calculating module eigengenes, gene module membership, and the correlating moduleâ€™s trend with other variables of interest. The most important parameter here is summary, whether we should take the average of the gene to calculate module eigengenes or use the native WGCNA approach (1st PC):</p> <div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">analyze_network</span><span class="o">=</span><span class="k">function</span><span class="w"> </span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">multiExpr</span><span class="p">,</span><span class="w"> </span><span class="n">meta</span><span class="p">,</span><span class="w"> </span><span class="n">use</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"pairwise.complete.obs"</span><span class="p">,</span><span class="w"> 
    </span><span class="n">scale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">T</span><span class="p">,</span><span class="w"> </span><span class="n">summary</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"pc"</span><span class="p">)</span><span class="w"> 
</span><span class="p">{</span><span class="w">
    </span><span class="s1">'''
    parameter:
        net: the list of network constructed from the previous step (construct_network)
        multiExpr:the list of normalized matrices from step1 (preprocess_input)
        meta: the metadata obtained from step1
        use: this will be feed into the correlation function. for example use="p" means use the none NA entries
        scale: whether to scale the data before correlation calculation. this is advised for using the mean trend strategy (summary ="mean")
        summary: whether to take the average value of the genes within each module ("mean"), or use WGCNA  module eigengene ("pc") 


    output: 
        cor_df: a dataframe storing  correlation coefficients between each module and variables of interest 
        p_df: a dataframe storing  correlation p-value between each module and variables of interest 
        group_gene: a named lists where each element is a list of genes per module
        geneModuleMembership: the membership of each gene to all modules
        mergedColors: the assignment of each gene to their module (color as the module nmae)

    '''</span><span class="w">
    </span><span class="n">mergedColors</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lapply</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">labels2colors</span><span class="p">(</span><span class="n">i</span><span class="o">$</span><span class="n">colors</span><span class="p">))</span><span class="w">
    </span><span class="nf">names</span><span class="p">(</span><span class="n">mergedColors</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="nf">names</span><span class="p">(</span><span class="n">net</span><span class="p">)</span><span class="w">
    </span><span class="n">geneModuleMembership</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lapply</span><span class="p">(</span><span class="nf">names</span><span class="p">(</span><span class="n">net</span><span class="p">),</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">as.data.frame</span><span class="p">(</span><span class="n">WGCNA</span><span class="o">::</span><span class="n">cor</span><span class="p">(</span><span class="n">multiExpr</span><span class="p">[[</span><span class="n">i</span><span class="p">]]</span><span class="o">$</span><span class="n">data</span><span class="p">,</span><span class="w"> 
        </span><span class="n">net</span><span class="p">[[</span><span class="n">i</span><span class="p">]]</span><span class="o">$</span><span class="n">MEs</span><span class="p">,</span><span class="w"> </span><span class="n">use</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">use</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s2">"spearman"</span><span class="p">)))</span><span class="w">
    </span><span class="nf">names</span><span class="p">(</span><span class="n">geneModuleMembership</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">names</span><span class="p">(</span><span class="n">net</span><span class="p">)</span><span class="w">
    </span><span class="n">group_gene</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lapply</span><span class="p">(</span><span class="nf">names</span><span class="p">(</span><span class="n">net</span><span class="p">),</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">split</span><span class="p">(</span><span class="n">colnames</span><span class="p">(</span><span class="n">multiExpr</span><span class="p">[[</span><span class="n">i</span><span class="p">]]</span><span class="o">$</span><span class="n">data</span><span class="p">),</span><span class="w"> 
        </span><span class="n">mergedColors</span><span class="p">[[</span><span class="n">i</span><span class="p">]]))</span><span class="w">
    </span><span class="n">MMPvalue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lapply</span><span class="p">(</span><span class="nf">names</span><span class="p">(</span><span class="n">net</span><span class="p">),</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">as.data.frame</span><span class="p">(</span><span class="n">corPvalueStudent</span><span class="p">(</span><span class="n">as.matrix</span><span class="p">(</span><span class="n">geneModuleMembership</span><span class="p">[[</span><span class="n">i</span><span class="p">]]),</span><span class="w"> 
        </span><span class="n">ncol</span><span class="p">(</span><span class="n">net</span><span class="p">[[</span><span class="n">i</span><span class="p">]]))))</span><span class="w">
    </span><span class="n">print</span><span class="p">(</span><span class="s2">"test"</span><span class="p">)</span><span class="w">
    </span><span class="nf">names</span><span class="p">(</span><span class="n">group_gene</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">names</span><span class="p">(</span><span class="n">net</span><span class="p">)</span><span class="w">
    </span><span class="nf">names</span><span class="p">(</span><span class="n">MMPvalue</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">names</span><span class="p">(</span><span class="n">net</span><span class="p">)</span><span class="w">
    </span><span class="nf">names</span><span class="p">(</span><span class="n">mergedColors</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">names</span><span class="p">(</span><span class="n">net</span><span class="p">)</span><span class="w">
    </span><span class="n">groups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">names</span><span class="p">(</span><span class="n">net</span><span class="p">)</span><span class="w">
    </span><span class="n">cor_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lapply</span><span class="p">(</span><span class="nf">names</span><span class="p">(</span><span class="n">net</span><span class="p">),</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="n">nGenes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ncol</span><span class="p">(</span><span class="n">multiExpr</span><span class="p">[[</span><span class="n">i</span><span class="p">]]</span><span class="o">$</span><span class="n">data</span><span class="p">)</span><span class="w">
        </span><span class="n">nSamples</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nrow</span><span class="p">(</span><span class="n">multiExpr</span><span class="p">[[</span><span class="n">i</span><span class="p">]]</span><span class="o">$</span><span class="n">data</span><span class="p">)</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">scale</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="n">tmp_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scale</span><span class="p">(</span><span class="n">multiExpr</span><span class="p">[[</span><span class="n">i</span><span class="p">]]</span><span class="o">$</span><span class="n">data</span><span class="p">)</span><span class="w">
        </span><span class="p">}</span><span class="w">
        </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="n">tmp_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">multiExpr</span><span class="p">[[</span><span class="n">i</span><span class="p">]]</span><span class="o">$</span><span class="n">data</span><span class="p">[</span><span class="n">rownames</span><span class="p">(</span><span class="n">meta</span><span class="p">[[</span><span class="n">i</span><span class="p">]]),</span><span class="w"> 
                </span><span class="p">])</span><span class="w">
        </span><span class="p">}</span><span class="w">
        </span><span class="n">print</span><span class="p">(</span><span class="nf">dim</span><span class="p">(</span><span class="n">tmp_data</span><span class="p">))</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">summary</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">"mean"</span><span class="p">)</span><span class="w"> 
            </span><span class="n">MEs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">orderMEs</span><span class="p">(</span><span class="n">moduleMeangenes</span><span class="p">(</span><span class="n">tmp_data</span><span class="p">,</span><span class="w"> </span><span class="n">mergedColors</span><span class="p">[[</span><span class="n">i</span><span class="p">]]))</span><span class="w">
        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">summary</span><span class="w"> </span><span class="o">==</span><span class="s2">"pc"</span><span class="p">)</span><span class="w"> </span><span class="n">MEs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">orderMEs</span><span class="p">(</span><span class="n">moduleEigengenes</span><span class="p">(</span><span class="n">tmp_data</span><span class="p">,</span><span class="w"> </span><span class="n">mergedColors</span><span class="p">[[</span><span class="n">i</span><span class="p">]])</span><span class="o">$</span><span class="n">eigengenes</span><span class="p">)</span><span class="w">
        </span><span class="n">moduleTraitCor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">WGCNA</span><span class="o">::</span><span class="n">cor</span><span class="p">(</span><span class="n">MEs</span><span class="p">,</span><span class="w"> </span><span class="n">meta</span><span class="p">[[</span><span class="n">i</span><span class="p">]],</span><span class="w"> </span><span class="n">use</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">use</span><span class="p">,</span><span class="w"> 
            </span><span class="n">method</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"pearson"</span><span class="p">)</span><span class="w">
        </span><span class="n">moduleTraitPvalue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">corPvalueStudent</span><span class="p">(</span><span class="n">moduleTraitCor</span><span class="p">,</span><span class="w"> 
            </span><span class="n">nSamples</span><span class="p">)</span><span class="w">
        </span><span class="n">rownames</span><span class="p">(</span><span class="n">moduleTraitCor</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">paste0</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="s2">"_"</span><span class="p">,</span><span class="w"> </span><span class="n">rownames</span><span class="p">(</span><span class="n">moduleTraitCor</span><span class="p">))</span><span class="w">
        </span><span class="n">rownames</span><span class="p">(</span><span class="n">moduleTraitPvalue</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">paste0</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="s2">"_"</span><span class="p">,</span><span class="w"> </span><span class="n">rownames</span><span class="p">(</span><span class="n">moduleTraitPvalue</span><span class="p">))</span><span class="w">
        </span><span class="nf">return</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">Cor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">moduleTraitCor</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">moduleTraitPvalue</span><span class="p">))</span><span class="w">
    </span><span class="p">})</span><span class="w">
    </span><span class="n">cor_df</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data.frame</span><span class="p">(</span><span class="n">do.call</span><span class="p">(</span><span class="n">plyr</span><span class="o">::</span><span class="n">rbind.fill</span><span class="p">,</span><span class="w"> </span><span class="n">lapply</span><span class="p">(</span><span class="n">cor_result</span><span class="p">,</span><span class="w"> 
        </span><span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">data.frame</span><span class="p">(</span><span class="n">i</span><span class="o">$</span><span class="n">Cor</span><span class="p">,</span><span class="w"> </span><span class="n">rownames</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rownames</span><span class="p">(</span><span class="n">i</span><span class="o">$</span><span class="n">Cor</span><span class="p">)))))</span><span class="w">
    </span><span class="n">rownames</span><span class="p">(</span><span class="n">cor_df</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">unlist</span><span class="p">(</span><span class="n">sapply</span><span class="p">(</span><span class="n">cor_result</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">rownames</span><span class="p">(</span><span class="n">i</span><span class="o">$</span><span class="n">Cor</span><span class="p">)))</span><span class="w">
    </span><span class="n">p_df</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data.frame</span><span class="p">(</span><span class="n">do.call</span><span class="p">(</span><span class="n">plyr</span><span class="o">::</span><span class="n">rbind.fill</span><span class="p">,</span><span class="w"> </span><span class="n">lapply</span><span class="p">(</span><span class="n">cor_result</span><span class="p">,</span><span class="w"> 
        </span><span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">data.frame</span><span class="p">(</span><span class="n">i</span><span class="o">$</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">rownames</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rownames</span><span class="p">(</span><span class="n">i</span><span class="o">$</span><span class="n">p</span><span class="p">)))))</span><span class="w">
    </span><span class="n">rownames</span><span class="p">(</span><span class="n">p_df</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">unlist</span><span class="p">(</span><span class="n">sapply</span><span class="p">(</span><span class="n">cor_result</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">rownames</span><span class="p">(</span><span class="n">i</span><span class="o">$</span><span class="n">p</span><span class="p">)))</span><span class="w">
    </span><span class="nf">return</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">cor_df</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cor_df</span><span class="p">,</span><span class="w"> </span><span class="n">p_df</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p_df</span><span class="p">,</span><span class="n">group_gene</span><span class="o">=</span><span class="n">group_gene</span><span class="p">,</span><span class="n">geneModuleMembership</span><span class="o">=</span><span class="n">geneModuleMembership</span><span class="p">,</span><span class="w">
               </span><span class="n">mergedColors</span><span class="o">=</span><span class="n">mergedColors</span><span class="p">))</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <p>With these helper functions, the proper way to construct networks across multiple cell populations is like the following:</p> <div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">step1</span><span class="o">=</span><span class="n">preprocess_input</span><span class="p">(</span><span class="n">meta_file</span><span class="o">=</span><span class="s2">"/projects/Thyroid/Results_nuc/7_NetworkAnalysis/Eco_system/Eco_all_meta.csv"</span><span class="p">,</span><span class="w">
                          </span><span class="n">count_file</span><span class="o">=</span><span class="s2">"/projects/Thyroid/Results_nuc/7_NetworkAnalysis/Eco_system/Eco_all_count.csv"</span><span class="p">,</span><span class="w">
                       </span><span class="n">vst</span><span class="o">=</span><span class="nb">T</span><span class="p">,</span><span class="n">cluster_label</span><span class="o">=</span><span class="s2">"cluster"</span><span class="p">,</span><span class="n">sample_label</span><span class="o">=</span><span class="s2">"Channel"</span><span class="w">
                </span><span class="p">,</span><span class="n">vars_to_keep</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="s2">"Channel"</span><span class="p">,</span><span class="s2">"immune_infiltration_percent"</span><span class="p">,</span><span class="s2">"Condition"</span><span class="p">),</span><span class="n">normalize</span><span class="o">=</span><span class="nb">T</span><span class="p">,</span><span class="w">
                          </span><span class="n">cluster_to_use</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="s2">"all"</span><span class="p">),</span><span class="n">normalize_method</span><span class="o">=</span><span class="s2">"edgeR"</span><span class="p">,</span><span class="w">
                        </span><span class="n">remove_genes</span><span class="o">=</span><span class="n">Ig_rm</span><span class="p">,</span><span class="n">remove_missing</span><span class="o">=</span><span class="m">10</span><span class="p">)</span><span class="w">
</span><span class="n">step1</span><span class="p">[[</span><span class="m">3</span><span class="p">]]</span><span class="o">$</span><span class="n">Eco_all</span><span class="o">$</span><span class="n">log_immune_infiltration_percent</span><span class="o">=</span><span class="n">log10</span><span class="p">(</span><span class="nf">as.numeric</span><span class="p">(</span><span class="n">step1</span><span class="p">[[</span><span class="m">3</span><span class="p">]]</span><span class="o">$</span><span class="n">Eco_all</span><span class="o">$</span><span class="n">immune_infiltration_percent</span><span class="p">))</span><span class="w">

</span><span class="n">find_power</span><span class="p">(</span><span class="n">step1</span><span class="p">[[</span><span class="m">2</span><span class="p">]])</span><span class="w">

</span><span class="n">net</span><span class="o">=</span><span class="n">construct_network</span><span class="p">(</span><span class="n">step1</span><span class="p">[[</span><span class="m">2</span><span class="p">]],</span><span class="n">save_output</span><span class="o">=</span><span class="s2">"/working-dir/net.RDS"</span><span class="p">)</span><span class="w">

</span><span class="n">cor_result</span><span class="o">=</span><span class="n">analyze_network</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="n">step1</span><span class="p">[[</span><span class="m">2</span><span class="p">]],</span><span class="n">step1</span><span class="p">[[</span><span class="m">3</span><span class="p">]],</span><span class="n">summary</span><span class="o">=</span><span class="s2">"mean"</span><span class="p">)</span><span class="w">

</span></code></pre></div></div> </div> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> Â© Copyright 2023 Hoang (Anh) Tran. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?07b8786bab9b4abe90d10e61f7d12ff7" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-1W7V2Y0MXW"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-1W7V2Y0MXW");</script> <script async src="https://rum.cronitor.io/script.js"></script> <script>window.cronitor=window.cronitor||function(){(window.cronitor.q=window.cronitor.q||[]).push(arguments)},cronitor("config",{clientKey:""});</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>