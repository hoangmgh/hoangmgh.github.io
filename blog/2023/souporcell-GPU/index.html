<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>üì¢ Genetic-demultiplexing with Souporcell - GPU implementation | Hoang (Anh) Tran</title> <meta name="author" content="Hoang (Anh) Tran"> <meta name="description" content="speed up demultiplexing with GPU Tensorflow"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://hoangmgh.github.io/blog/2023/souporcell-GPU/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> </head> <body> <p> {% if jekyll.environment == 'production' and site.google_analytics %} {% include analytics.html %} {% endif %} </p> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Hoang¬†</span>(Anh)¬†Tran</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Bioinformatics<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Arts</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">üì¢ Genetic-demultiplexing with Souporcell - GPU implementation</h1> <p class="post-meta">November 15, 2023</p> <p class="post-tags"> <a href="/blog/2023"> <i class="fa-solid fa-calendar fa-sm"></i> 2023 </a> ¬† ¬∑ ¬† <a href="/blog/tag/math"> <i class="fa-solid fa-hashtag fa-sm"></i> math</a> ¬† <a href="/blog/tag/genetic-demultiplexing"> <i class="fa-solid fa-hashtag fa-sm"></i> genetic-demultiplexing</a> ¬† ¬† ¬∑ ¬† <a href="/blog/category/bioinformatics"> <i class="fa-solid fa-tag fa-sm"></i> Bioinformatics</a> ¬† </p> </header> <article class="post-content"> <div id="markdown-content"> <p>I rewrote souporcell so it can be run on GPU with half of the time required. This can be particularly useful if you need to tune parameters several times for an experiment</p> <p>Then the whole <a href="https://github.com/wheaton5/souporcell/blob/master/souporcell_pipeline.py" rel="external nofollow noopener" target="_blank">souporcell.py</a> can be broken down do three components: read_mtx(), cluster_step(). The cluster step can benefit from running on GPU. Basically we can replace <strong><em>tf.</em></strong> with <strong><em>tf.compat.v1</em></strong>, and run the Gradient Descent step with the with <strong><em>with tf.device(‚Äú/GPU:0‚Äù)</em></strong> : The first step is to read in the matrices (ref.mtx and alt.mtx), filter out loci that are expressed in at least \(min_{alt}\) and \(min_{ref}\) cells, and finally create a list of possible loci and their corresponding indices to be used. We call this the ‚Äúpool of indices‚Äù, from where we will go on to the cluster step and do more filtering:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">read_mtx</span><span class="p">(</span><span class="n">min_alt</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span><span class="n">min_ref</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span><span class="n">K</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span><span class="n">max_loci</span> <span class="o">=</span><span class="mi">1024</span><span class="p">,</span><span class="n">alt_matrix</span><span class="o">=</span><span class="sh">"</span><span class="s">alt_simulated.mtx</span><span class="sh">"</span><span class="p">,</span><span class="n">ref_matrix</span><span class="o">=</span><span class="sh">"</span><span class="s">ref_simulated.mtx</span><span class="sh">"</span><span class="p">):</span>
    <span class="n">cell_index</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">total_lost</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">loci_counts</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">cell_counts</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="n">alt_matrix</span><span class="p">)</span> <span class="k">as</span> <span class="n">alt</span><span class="p">:</span>
        <span class="n">alt</span><span class="p">.</span><span class="nf">readline</span><span class="p">()</span>
        <span class="n">alt</span><span class="p">.</span><span class="nf">readline</span><span class="p">()</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="n">alt</span><span class="p">.</span><span class="nf">readline</span><span class="p">().</span><span class="nf">strip</span><span class="p">().</span><span class="nf">split</span><span class="p">()</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">cell_counts</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="p">{}</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cells</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span>
        <span class="n">total_loci</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">alt</span><span class="p">:</span>
            <span class="n">tokens</span> <span class="o">=</span> <span class="n">line</span><span class="p">.</span><span class="nf">strip</span><span class="p">().</span><span class="nf">split</span><span class="p">()</span>
            <span class="n">locus</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">cell_counts</span><span class="p">.</span><span class="nf">setdefault</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="p">{})</span>
            <span class="n">count</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">cell_counts</span><span class="p">[</span><span class="n">cell</span><span class="p">][</span><span class="n">locus</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">count</span><span class="p">]</span>
            <span class="n">loci_counts</span><span class="p">.</span><span class="nf">setdefault</span><span class="p">(</span><span class="n">locus</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">loci_counts</span><span class="p">[</span><span class="n">locus</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="n">ref_matrix</span><span class="p">)</span> <span class="k">as</span> <span class="n">alt</span><span class="p">:</span>
        <span class="n">alt</span><span class="p">.</span><span class="nf">readline</span><span class="p">()</span>
        <span class="n">alt</span><span class="p">.</span><span class="nf">readline</span><span class="p">()</span>
        <span class="n">alt</span><span class="p">.</span><span class="nf">readline</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">alt</span><span class="p">:</span>
            <span class="n">tokens</span> <span class="o">=</span> <span class="n">line</span><span class="p">.</span><span class="nf">strip</span><span class="p">().</span><span class="nf">split</span><span class="p">()</span>
            <span class="n">locus</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">count</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">cell_counts</span><span class="p">[</span><span class="n">cell</span><span class="p">][</span><span class="n">locus</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
            <span class="n">loci_counts</span><span class="p">.</span><span class="nf">setdefault</span><span class="p">(</span><span class="n">locus</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">loci_counts</span><span class="p">[</span><span class="n">locus</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">used_loci_set</span> <span class="o">=</span> <span class="nf">set</span><span class="p">()</span>
    <span class="n">used_loci</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="nf">for </span><span class="p">(</span><span class="n">locus</span><span class="p">,</span> <span class="n">counts</span><span class="p">)</span> <span class="ow">in</span> <span class="n">loci_counts</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">min_ref</span> <span class="ow">and</span> <span class="n">counts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">min_alt</span><span class="p">:</span>
            <span class="n">used_loci</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">locus</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">used_loci_set</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">locus</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">used_loci</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">(</span><span class="n">used_loci</span><span class="p">)</span>
    <span class="n">used_loci_indices</span> <span class="o">=</span> <span class="p">{</span><span class="n">locus</span><span class="p">:</span><span class="n">i</span> <span class="nf">for </span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">locus</span><span class="p">)</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">used_loci</span><span class="p">)}</span>
    <span class="n">loci</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">used_loci</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">used_loci_indices</span><span class="p">,</span><span class="n">used_loci_set</span><span class="p">,</span><span class="n">used_loci</span><span class="p">,</span><span class="n">loci</span><span class="p">,</span><span class="n">loci_counts</span><span class="p">,</span><span class="n">cell_counts</span>
</code></pre></div></div> <p>The next step is called the cluster step, where we build the fractional matrices for all cell. However, each cell will have their own set of loci and might not be overlapping with other sets from other cells. This is quite interesting! It is also important that one can use up to \(max_{loci}\) loci (default =1024). Regardless, the set of loci for each cell must satisfy:</p> <ul> <li>they must be pooled from the pool of cells identified earlier (used_loci_indices)</li> <li>the loci are considered if they are expressed in the given cell ( ref_count &gt; 0 and alt_count &gt; 0)</li> </ul> <p>I am adding a parameter for known_cells, where the indices of known cells and their corresponding cluster number must be provided (a dataframe) This works by assigning a maximal weight to the known cluster:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">weightshape_np</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">transpose</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">broadcast_to</span><span class="p">(</span><span class="n">weights</span><span class="p">.</span><span class="n">T</span><span class="p">,(</span><span class="n">K</span><span class="p">,</span><span class="n">max_loci</span><span class="p">,</span><span class="n">weights</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))))</span>

   
        
    <span class="k">if</span> <span class="n">known_cells</span>  <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nf">len</span><span class="p">(</span><span class="n">known_cells</span><span class="p">.</span><span class="nf">keys</span><span class="p">())</span> <span class="o">&lt;=</span> <span class="n">K</span>
        <span class="k">assert</span> <span class="n">known_cells</span><span class="p">.</span><span class="n">columns</span><span class="o">==</span><span class="p">[</span><span class="sh">"</span><span class="s">index</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">cluster</span><span class="sh">"</span><span class="p">]</span>
        <span class="c1">#did a quick check for unique assignment to a cluster:
</span>        <span class="n">freq</span><span class="o">=</span><span class="n">known_cell</span><span class="p">[</span><span class="sh">"</span><span class="s">cluster</span><span class="sh">"</span><span class="p">].</span><span class="nf">value_counts</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">np</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span>
        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">known_cells</span><span class="p">.</span><span class="nf">keys</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">k</span><span class="o">!=</span><span class="n">i</span><span class="p">:</span>
                    <span class="n">weightshape_np</span><span class="p">[</span><span class="n">known_cells</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,:,</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">weightshape_np</span><span class="p">[</span><span class="n">known_cells</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,:,</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="mi">10000</span>    
</code></pre></div></div> <p>and so the likelihood of seeing a known cell‚Äôs genotype vector is: \begin{equation} P(x=v_c) = e^{-\frac{1}{2}|v_c-\theta_k|} \end{equation} given that cell \(c\) is drawn from a Gaussian centered at \(\theta_k\) Instead of assigning the weights with 10000, perhaps there is a better way to represent ‚Äúmaximal distance‚Äù of \(v_c\) from other \(\theta_1\), \(\theta_2\),‚Ä¶ but not \(\theta_k\)‚Ä¶</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>


<span class="k">def</span> <span class="nf">cluster_step</span><span class="p">(</span><span class="n">max_loci</span><span class="p">,</span><span class="n">K</span><span class="p">,</span><span class="n">training_epochs</span><span class="p">,</span><span class="n">repeats</span><span class="p">,</span><span class="n">cell_counts</span><span class="p">,</span><span class="n">loci_counts</span><span class="p">,</span><span class="n">used_loci_indices</span><span class="p">,</span><span class="n">known_cells</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">min_ref</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">min_alt</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">lr</span><span class="o">=</span><span class="p">.</span><span class="mi">1</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">loci being us based on min_alt, min_ref, and max_loci </span><span class="sh">"</span><span class="o">+</span><span class="nf">str</span><span class="p">(</span><span class="n">loci</span><span class="p">))</span>
    <span class="n">cells</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">cell_counts</span><span class="p">)</span>
    <span class="n">total_lost</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">cell_data</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">cells</span><span class="p">,</span> <span class="n">max_loci</span><span class="p">))</span>
    <span class="n">cell_loci</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">cells</span><span class="p">,</span> <span class="n">max_loci</span><span class="p">))</span>
    
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">cells</span><span class="p">,</span> <span class="n">max_loci</span><span class="p">))</span>
    
    <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cell_counts</span><span class="p">.</span><span class="nf">keys</span><span class="p">():</span>
        <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">single_cell_counts</span> <span class="o">=</span> <span class="n">cell_counts</span><span class="p">[</span><span class="n">cell</span><span class="p">]</span>
        
        <span class="c1">#prioritize locus that is highly expressed across cells:
</span>        <span class="c1">#for this given cell, get the set of 
</span>        
        <span class="n">this_cell_locus</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span><span class="n">cell_counts</span><span class="p">[</span><span class="n">cell</span><span class="p">].</span><span class="nf">keys</span><span class="p">())</span>
       
             
        <span class="k">for</span> <span class="n">locus</span> <span class="ow">in</span> <span class="n">this_cell_locus</span><span class="p">:</span>
            <span class="n">locus_counts</span> <span class="o">=</span> <span class="n">single_cell_counts</span><span class="p">[</span><span class="n">locus</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">loci_counts</span><span class="p">[</span><span class="n">locus</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">min_ref</span> <span class="ow">and</span> <span class="n">loci_counts</span><span class="p">[</span><span class="n">locus</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">min_alt</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">max_loci</span><span class="p">:</span>
                    <span class="n">ref_c</span> <span class="o">=</span> <span class="n">locus_counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">alt_c</span> <span class="o">=</span> <span class="n">locus_counts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">ref_c</span> <span class="o">+</span> <span class="n">alt_c</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">cell_data</span><span class="p">[</span><span class="n">cell</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nf">float</span><span class="p">(</span><span class="n">ref_c</span><span class="p">)</span><span class="o">/</span><span class="nf">float</span><span class="p">(</span><span class="n">ref_c</span> <span class="o">+</span> <span class="n">alt_c</span><span class="p">)</span> <span class="k">if</span> <span class="n">ref_c</span> <span class="o">+</span> <span class="n">alt_c</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">0.0</span>
                        <span class="n">cell_loci</span><span class="p">[</span><span class="n">cell</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">used_loci_indices</span><span class="p">[</span><span class="n">locus</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="n">weights</span><span class="p">[</span><span class="n">cell</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
                        <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">total_lost</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1">### set 0 weights for cells from other clusters:
</span>    <span class="n">random_size</span><span class="o">=</span><span class="mi">100</span>


    <span class="n">data</span> <span class="o">=</span> <span class="n">cell_data</span>
    <span class="n">data_loci</span> <span class="o">=</span> <span class="n">cell_loci</span>
    <span class="n">weightshape_np</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">transpose</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">broadcast_to</span><span class="p">(</span><span class="n">weights</span><span class="p">.</span><span class="n">T</span><span class="p">,(</span><span class="n">K</span><span class="p">,</span><span class="n">max_loci</span><span class="p">,</span><span class="n">weights</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))))</span>

   
        
    <span class="k">if</span> <span class="n">known_cells</span>  <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nf">len</span><span class="p">(</span><span class="n">known_cells</span><span class="p">.</span><span class="nf">keys</span><span class="p">())</span> <span class="o">&lt;=</span> <span class="n">K</span>
        <span class="k">assert</span> <span class="n">known_cells</span><span class="p">.</span><span class="n">columns</span><span class="o">==</span><span class="p">[</span><span class="sh">"</span><span class="s">index</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">cluster</span><span class="sh">"</span><span class="p">]</span>
        <span class="c1">#did a quick check for unique assignment to a cluster:
</span>        <span class="n">freq</span><span class="o">=</span><span class="n">known_cell</span><span class="p">[</span><span class="sh">"</span><span class="s">cluster</span><span class="sh">"</span><span class="p">].</span><span class="nf">value_counts</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">np</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">known_cells</span><span class="p">.</span><span class="nf">keys</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">k</span><span class="o">!=</span><span class="n">i</span><span class="p">:</span>
                    <span class="n">weightshape_np</span><span class="p">[</span><span class="n">known_cells</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,:,</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">weightshape_np</span><span class="p">[</span><span class="n">known_cells</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,:,</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="mi">10000</span>    
    
    <span class="n">cells</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1">#save this for investigation:
</span>    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">save cell_data and cell_loci:</span><span class="sh">"</span><span class="p">)</span>
     
    <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span>
    
    
    <span class="kn">import</span> <span class="n">tensorflow</span> <span class="k">as</span> <span class="n">tf</span>
    
    <span class="n">session_conf</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">compat</span><span class="p">.</span><span class="n">v1</span><span class="p">.</span><span class="nc">ConfigProto</span><span class="p">(</span>
          <span class="n">allow_soft_placement</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">session_conf</span><span class="p">.</span><span class="n">gpu_options</span><span class="p">.</span><span class="n">allow_growth</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">session_conf</span><span class="p">.</span><span class="n">gpu_options</span><span class="p">.</span><span class="n">per_process_gpu_memory_fraction</span> <span class="o">=</span><span class="mi">1</span>
    <span class="n">tf</span><span class="p">.</span><span class="n">compat</span><span class="p">.</span><span class="n">v1</span><span class="p">.</span><span class="nf">disable_eager_execution</span><span class="p">()</span>
    
    <span class="n">tf</span><span class="p">.</span><span class="n">compat</span><span class="p">.</span><span class="n">v1</span><span class="p">.</span><span class="nf">reset_default_graph</span><span class="p">()</span>
    
    <span class="k">with</span> <span class="n">tf</span><span class="p">.</span><span class="nf">device</span><span class="p">(</span><span class="sh">"</span><span class="s">/GPU:0</span><span class="sh">"</span><span class="p">):</span>
    

        <span class="c1">#init = tf.compat.v1.constant(sample_genotypes.T)
</span>        <span class="c1">#phi = tf.compat.v1.get_variable(name="phi", initializer = init, dtype = tf.float64)
</span>        
        <span class="n">phi</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">compat</span><span class="p">.</span><span class="n">v1</span><span class="p">.</span><span class="nf">get_variable</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="sh">"</span><span class="s">phi</span><span class="sh">"</span><span class="p">,</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">loci</span><span class="p">,</span> <span class="n">K</span><span class="p">),</span> <span class="n">initializer</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">initializers</span><span class="p">.</span><span class="nf">random_uniform</span><span class="p">(</span><span class="n">minval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">maxval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="n">input_data</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">compat</span><span class="p">.</span><span class="n">v1</span><span class="p">.</span><span class="nf">placeholder</span><span class="p">(</span><span class="sh">"</span><span class="s">float64</span><span class="sh">"</span><span class="p">,</span> <span class="p">(</span><span class="n">cells</span><span class="p">,</span> <span class="n">max_loci</span><span class="p">))</span> <span class="c1">#tf.constant("input",np.asmatrix(data))
</span>        <span class="n">input_loci</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">compat</span><span class="p">.</span><span class="n">v1</span><span class="p">.</span><span class="nf">placeholder</span><span class="p">(</span><span class="sh">"</span><span class="s">int32</span><span class="sh">"</span><span class="p">,</span> <span class="p">(</span><span class="n">cells</span><span class="p">,</span> <span class="n">max_loci</span><span class="p">))</span>
        <span class="n">loci_per_cell</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">compat</span><span class="p">.</span><span class="n">v1</span><span class="p">.</span><span class="nf">placeholder</span><span class="p">(</span><span class="sh">"</span><span class="s">float64</span><span class="sh">"</span><span class="p">,</span> <span class="p">(</span><span class="n">cells</span><span class="p">))</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">compat</span><span class="p">.</span><span class="n">v1</span><span class="p">.</span><span class="nf">transpose</span><span class="p">(</span><span class="n">input_data</span><span class="p">)</span>
        <span class="n">broad_trans</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">compat</span><span class="p">.</span><span class="n">v1</span><span class="p">.</span><span class="nf">broadcast_to</span><span class="p">(</span><span class="n">trans</span><span class="p">,[</span><span class="n">K</span><span class="p">,</span><span class="n">max_loci</span><span class="p">,</span><span class="n">cells</span><span class="p">])</span>
        <span class="n">untrans</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">compat</span><span class="p">.</span><span class="n">v1</span><span class="p">.</span><span class="nf">transpose</span><span class="p">(</span><span class="n">broad_trans</span><span class="p">)</span>
        <span class="n">xtest</span> <span class="o">=</span> <span class="n">untrans</span><span class="o">-</span><span class="n">tf</span><span class="p">.</span><span class="n">compat</span><span class="p">.</span><span class="n">v1</span><span class="p">.</span><span class="nf">gather</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span><span class="n">input_loci</span><span class="p">)</span>
        <span class="n">weight_data</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">compat</span><span class="p">.</span><span class="n">v1</span><span class="p">.</span><span class="nf">placeholder</span><span class="p">(</span><span class="sh">"</span><span class="s">float64</span><span class="sh">"</span><span class="p">,</span> <span class="p">(</span><span class="n">cells</span><span class="p">,</span><span class="n">max_loci</span><span class="p">,</span><span class="n">K</span><span class="p">))</span> <span class="c1">#tf.constant("weights",np.asmatrix(weights))
</span>    
        <span class="n">weighted</span> <span class="o">=</span> <span class="n">weight_data</span><span class="o">*</span><span class="n">xtest</span>
        <span class="n">powtest</span> <span class="o">=</span> <span class="o">-</span><span class="n">tf</span><span class="p">.</span><span class="n">compat</span><span class="p">.</span><span class="n">v1</span><span class="p">.</span><span class="nf">pow</span><span class="p">(</span><span class="n">weighted</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">post</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">compat</span><span class="p">.</span><span class="n">v1</span><span class="p">.</span><span class="nf">reduce_sum</span><span class="p">(</span><span class="n">powtest</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">logsum</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">compat</span><span class="p">.</span><span class="n">v1</span><span class="p">.</span><span class="nf">reduce_logsumexp</span><span class="p">(</span><span class="n">post</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="o">-</span><span class="n">tf</span><span class="p">.</span><span class="n">compat</span><span class="p">.</span><span class="n">v1</span><span class="p">.</span><span class="nf">reduce_sum</span><span class="p">(</span><span class="n">logsum</span><span class="p">)</span>
    
        <span class="n">optimizer</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">compat</span><span class="p">.</span><span class="n">v1</span><span class="p">.</span><span class="n">train</span><span class="p">.</span><span class="nc">AdamOptimizer</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">lr</span><span class="p">).</span><span class="nf">minimize</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>
            
        <span class="n">posteriors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">min_cost</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">weightsshape</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">logsum_list</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">cluster_list</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">repeat</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">repeats</span><span class="p">):</span>
        <span class="n">init</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">compat</span><span class="p">.</span><span class="n">v1</span><span class="p">.</span><span class="nf">global_variables_initializer</span><span class="p">()</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">repeat </span><span class="sh">"</span><span class="o">+</span><span class="nf">str</span><span class="p">(</span><span class="n">repeat</span><span class="p">))</span>
        <span class="n">training_epochs</span> <span class="o">=</span> <span class="mi">1000</span>
        <span class="n">last_cost</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">with</span> <span class="n">tf</span><span class="p">.</span><span class="n">compat</span><span class="p">.</span><span class="n">v1</span><span class="p">.</span><span class="nc">Session</span><span class="p">(</span><span class="n">config</span> <span class="o">=</span> <span class="n">session_conf</span><span class="p">)</span> <span class="k">as</span> <span class="n">sess</span><span class="p">:</span>
            <span class="n">sess</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="n">init</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">training_epochs</span><span class="p">):</span>
                <span class="n">sess</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="n">optimizer</span><span class="p">,</span> <span class="n">feed_dict</span><span class="o">=</span><span class="p">{</span><span class="n">input_data</span><span class="p">:</span><span class="n">data</span><span class="p">,</span> <span class="n">weight_data</span><span class="p">:</span><span class="n">weightshape_np</span><span class="p">,</span> <span class="n">input_loci</span><span class="p">:</span><span class="n">data_loci</span><span class="p">})</span>
    
                <span class="k">if</span> <span class="n">epoch</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">sess</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="n">cost</span><span class="p">,</span> <span class="n">feed_dict</span><span class="o">=</span><span class="p">{</span><span class="n">input_data</span><span class="p">:</span><span class="n">data</span><span class="p">,</span> <span class="n">weight_data</span><span class="p">:</span><span class="n">weightshape_np</span><span class="p">,</span> <span class="n">input_loci</span><span class="p">:</span><span class="n">data_loci</span><span class="p">})</span>
                    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">epoch </span><span class="sh">"</span><span class="o">+</span><span class="nf">str</span><span class="p">(</span><span class="n">epoch</span><span class="p">)</span><span class="o">+</span><span class="sh">"</span><span class="s"> </span><span class="sh">"</span><span class="o">+</span><span class="nf">str</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
                    <span class="c1">#if last_cost and ((last_cost-c)/c) &lt; 0.0001:
</span>                    <span class="k">if</span> <span class="n">min_cost</span> <span class="ow">and</span> <span class="n">last_cost</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="n">min_cost</span> <span class="ow">and</span> <span class="p">(</span><span class="n">last_cost</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="n">min_cost</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.005</span><span class="p">:</span>
                        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">bailing out, too little progress toward minimum so far</span><span class="sh">"</span><span class="p">)</span>
                        <span class="k">break</span>
                    <span class="k">if</span> <span class="n">last_cost</span> <span class="ow">and</span> <span class="n">last_cost</span> <span class="o">-</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">last_cost</span> <span class="o">=</span> <span class="bp">None</span>
                        <span class="k">break</span>
                    <span class="n">last_cost</span> <span class="o">=</span> <span class="n">c</span>
            <span class="k">if</span> <span class="n">min_cost</span><span class="p">:</span>
                <span class="n">min_cost</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">min_cost</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">min_cost</span> <span class="o">=</span> <span class="n">c</span>
    
            <span class="n">posterior</span> <span class="o">=</span> <span class="n">sess</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="n">post</span><span class="p">,</span> <span class="n">feed_dict</span><span class="o">=</span><span class="p">{</span><span class="n">input_data</span><span class="p">:</span><span class="n">data</span><span class="p">,</span> <span class="n">weight_data</span><span class="p">:</span><span class="n">weightshape_np</span><span class="p">,</span> <span class="n">input_loci</span><span class="p">:</span><span class="n">data_loci</span><span class="p">})</span>
            <span class="n">posteriors</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">c</span><span class="p">,</span><span class="n">posterior</span><span class="p">))</span>
                
                
    
    <span class="n">sess</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
    
    <span class="n">posterior</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">(</span><span class="n">posteriors</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">posterior</span> <span class="o">=</span> <span class="n">posterior</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>    
    <span class="n">clusters</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">argmax</span><span class="p">(</span><span class="n">posterior</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="nf">return</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span>

</code></pre></div></div> <p>And then from your GPU-equipped computer, run the following:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">used_loci_indices</span><span class="p">,</span><span class="n">used_loci_set</span><span class="p">,</span><span class="n">used_loci</span><span class="p">,</span><span class="n">loci</span><span class="p">,</span><span class="n">loci_counts</span><span class="p">,</span><span class="n">cell_counts</span><span class="o">=</span><span class="nf">read_mtx</span><span class="p">(</span><span class="n">alt_matrix</span><span class="o">=</span><span class="sh">"</span><span class="s">alt.mtx</span><span class="sh">"</span><span class="p">,</span>
                                                                                <span class="n">ref_matrix</span><span class="o">=</span><span class="sh">"</span><span class="s">ref.mtx</span><span class="sh">"</span><span class="p">)</span>
<span class="n">clusters</span><span class="o">=</span><span class="nf">cluster_step</span><span class="p">(</span><span class="n">max_loci</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span><span class="n">K</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span><span class="n">training_epochs</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span><span class="n">repeats</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span><span class="n">cell_counts</span><span class="o">=</span><span class="n">cell_counts</span><span class="p">,</span>
                      <span class="n">loci_counts</span><span class="o">=</span><span class="n">loci_counts</span><span class="p">,</span><span class="n">used_loci_indices</span><span class="o">=</span><span class="n">used_loci_indices</span><span class="p">,</span>
                      <span class="n">cluster_tmp</span><span class="o">=</span><span class="sh">"</span><span class="s">cluster_simulated.tsv</span><span class="sh">"</span><span class="p">,</span><span class="n">known_cells</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">min_ref</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">min_alt</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">lr</span><span class="o">=</span><span class="p">.</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div> <p>I randomly select 100 cells from each known cluster from an earlier experiment, and here is the performance in the case of imbalance-dataset:</p> </div> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> ¬© Copyright 2023 Hoang (Anh) Tran. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?07b8786bab9b4abe90d10e61f7d12ff7" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-1W7V2Y0MXW"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-1W7V2Y0MXW");</script> <script async src="https://rum.cronitor.io/script.js"></script> <script>window.cronitor=window.cronitor||function(){(window.cronitor.q=window.cronitor.q||[]).push(arguments)},cronitor("config",{clientKey:""});</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>